{"ts":1352693525991,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"%{\n/******************************************************************************\n * File: grammar.y\n * Authors: Evelina Arthursson, Derek McLean, Hugo Ribeiro\n *      *original content: Carol Zander\n * This is a grammar file that defines the grammar rules for a Pascal-like\n * language.\n * 10/16 - It currently only displays the text of unique identifiers (not\n *         keywords or symbols).\n */\n\n/* declarations section */\n#include \"stack.h\"\n#include \"Procedure.h\"\n\n#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <deque>\n\nextern Stack scopeStack;\nusing namespace std;\n\n%}\n\n%union {\n    const char *text;\n    Procedure *procedure;\n    deque<Parameter> parameterQueue;\n    deque<string> identQueue;\n}\n\n/* definition section */\n\n%start  CompilationUnit\n%type   <procedure> ProcedureHeading\n%type   <parameterQueue> FormalParameters FormalParamList OneFormalParam\n%type   <identQueue> IdentList\n%token  yand yarray yassign ybegin ycaret ycase ycolon ycomma yconst ydispose \n        ydiv ydivide ydo  ydot ydotdot ydownto yelse yend yequal yfalse\n        yfor yfunction ygreater ygreaterequal         yif yin yleftbracket\n        yleftparen yless ylessequal yminus ymod ymultiply ynew ynil ynot \n        ynotequal ynumber yof  yor yplus yprocedure yprogram yread yreadln  \n        yrecord yrepeat yrightbracket yrightparen  ysemicolon yset \n        ythen  yto ytrue ytype  yuntil  yvar ywhile ywrite ywriteln yunknown\n%token <text> yident ystring\n\n%%\n/* rules section */\n\n/**************************  Pascal program **********************************/\n\nCompilationUnit    :  ProgramModule\n                   ;\nProgramModule      :  yprogram yident\n                                {\n                                    printf(\"%s \", $2);\n                                }\n                      ProgramParameters ysemicolon\n                                { \n                                    /* Enter Program Scope */\n                                    scopeStack.createScope(string($2));\n                                    /* TODO : Put Program parameters on stack?? */\n                                }\n                      Block ydot\n                   ;\nProgramParameters  :  yleftparen  IdentList  yrightparen\n                   ;\nIdentList          :  yident \n                                {\n                                    printf(\"%s \", $1);\n                                    $$.push_back($1);\n                                }\n                   |  IdentList ycomma yident\n                                {\n                                    printf(\"%s \", $3);\n                                    $$.push_back($1);\n                                }\n                   ;\n\n/**************************  Declarations section ***************************/\n\nBlock              :  Declarations  ybegin  StatementSequence  yend\n                   ;\nDeclarations       :  ConstantDefBlock\n                      TypeDefBlock\n                      VariableDeclBlock\n                      SubprogDeclList\n                   ;\nConstantDefBlock   :  yconst ConstDefList\n           |  /*** empty ***/\n                   ;\nConstDefList       :  ConstantDef ysemicolon\n                   |  ConstDefList ConstantDef ysemicolon\n                   ;\nTypeDefBlock       :  /*** empty ***/\n                   |  ytype  TypeDefList\n                   ;\nTypeDefList        :  TypeDef  ysemicolon\n                   |  TypeDefList TypeDef ysemicolon\n                   ;\nVariableDeclBlock  :  yvar VariableDeclList\n           |  /*** empty ***/\n                   ;\nVariableDeclList   :  VariableDecl ysemicolon\n           |  VariableDeclList VariableDecl ysemicolon\n                   ;  \nConstantDef        :  yident\n                                {\n                                    printf(\"%s \", $1);\n                                }\n                      yequal  ConstExpression\n                   ;\nTypeDef            :  yident\n                                {\n                                    printf(\"%s \", $1);\n                                }\n                      yequal  Type\n                   ;\nVariableDecl       :  IdentList  ycolon  Type\n                   ;\n\n/***************************  Const/Type Stuff  ******************************/\n\nConstExpression    :  UnaryOperator ConstFactor\n           |  ConstFactor\n                   |  ystring\n           |  ynil\n                   ;\nConstFactor        :  yident    {\n                                    printf(\"%s \", $1);\n                                }\n                   |  ynumber\n                   |  ytrue\n                   |  yfalse\n                   ;\nType               :  yident    {\n                                    printf(\"%s \", $1);\n                                }\n                   |  ArrayType\n                   |  PointerType\n                   |  RecordType\n                   |  SetType\n                   ;\nArrayType          :  yarray yleftbracket Subrange SubrangeList\n                      yrightbracket  yof Type\n                   ;\nSubrangeList       :  /*** empty ***/\n                   |  SubrangeList ycomma Subrange \n                   ;\nSubrange           :  ConstFactor ydotdot ConstFactor\n                   |  ystring ydotdot  ystring\n                   ;\nRecordType         :  yrecord  FieldListSequence  yend\n                   ;\nSetType            :  yset  yof  Subrange\n                   ;\nPointerType        :  ycaret  yident\n                                {\n                                    printf(\"%s \", $2);\n                                }\n                   ;\nFieldListSequence  :  FieldList  \n                   |  FieldListSequence  ysemicolon  FieldList\n                   ;\nFieldList          :  IdentList  ycolon  Type\n                   ;\n\n/***************************  Statements  ************************************/\n\nStatementSequence  :  Statement  \n                   |  StatementSequence  ysemicolon  Statement\n                   ;\nStatement          :  Assignment\n                   |  ProcedureCall\n                      {\n                          //Handle procedue calls\n                      }\n                   |  IfStatement\n                   |  CaseStatement\n                   |  WhileStatement\n                   |  RepeatStatement\n                   |  ForStatement\n                   |  IOStatement\n                   |  MemoryStatement\n                   |  ybegin StatementSequence yend\n                   |  /*** empty ***/\n                   ;\nAssignment         :  Designator yassign Expression\n                   ;\nProcedureCall      :  yident \n                                {\n                                    printf(\"%s \", $1);\n                                }\n                   |  yident \n                                {\n                                    printf(\"%s \", $1);\n                                }\n                      ActualParameters\n                   ;\nIfStatement        :  yif  Expression  ythen  Statement EndIf\n           |  yif  Expression  ythen  Statement yelse Statement  EndIf\n                   ;  \nEndIf          :  /*** empty ***/\n           ;\nCaseStatement      :  ycase  Expression  yof  CaseList  yend\n                   ;\nCaseList           :  Case\n                   |  CaseList  ysemicolon  Case\n                   ;\nCase               :  CaseLabelList  ycolon  Statement\n                   ;\nCaseLabelList      :  ConstExpression\n                   |  CaseLabelList  ycomma  ConstExpression\n                   ;\nWhileStatement     :  ywhile  Expression  ydo  Statement\n                   ;\nRepeatStatement    :  yrepeat  StatementSequence  yuntil  Expression\n                   ;\nForStatement       :  yfor  yident  \n                                {\n                                    printf(\"%s \", $2);\n                                }\n                            yassign  Expression  WhichWay  Expression\n                            ydo  Statement\n                   ;\nWhichWay           :  yto  |  ydownto\n                   ;\nIOStatement        :  yread  yleftparen  DesignatorList  yrightparen\n                   |  yreadln  \n                   |  yreadln  yleftparen DesignatorList  yrightparen\n                   |  ywrite  yleftparen  ExpList  yrightparen\n                   |  ywriteln  \n                   |  ywriteln  yleftparen  ExpList  yrightparen\n                   ;\n\n/***************************  Designator Stuff  ******************************/\n\nDesignatorList     :  Designator  \n                   |  DesignatorList  ycomma  Designator\n                   ;\nDesignator         :  yident  \n                                {\n                                   printf(\"%s \", $1);\n                                }\n                      DesignatorStuff\n                   ;\nDesignatorStuff    :  /*** empty ***/\n                   |  DesignatorStuff  theDesignatorStuff\n                   ;\ntheDesignatorStuff :  ydot yident\n                                {\n                                    printf(\"%s \", $2);\n                                } \n                   |  yleftbracket ExpList yrightbracket\n                   |  ycaret\n                   ;\nActualParameters   :  yleftparen  ExpList  yrightparen\n                   ;\nExpList            :  Expression\n                   |  ExpList  ycomma  Expression\n                   ;\nMemoryStatement    :  ynew  yleftparen  yident\n                                {\n                                    printf(\"%s \", $3);\n                                }\n                      yrightparen\n                   |  ydispose yleftparen  yident\n                                {\n                                    printf(\"%s \", $3);\n                                }\n                      yrightparen\n                   ;\n\n/***************************  Expression Stuff  ******************************/\n\nExpression         :  SimpleExpression\n                   |  SimpleExpression  Relation  SimpleExpression\n                   ;\nSimpleExpression   :  TermExpr\n                   |  UnaryOperator  TermExpr\n                   ;\nTermExpr           :  Term  \n                   |  TermExpr  AddOperator  Term\n                   ;\nTerm               :  Factor  \n                   |  Term  MultOperator  Factor\n                   ;\nFactor             :  ynumber\n                   |  ytrue\n                   |  yfalse\n                   |  ynil\n                   |  ystring\n                   |  Designator\n                   |  yleftparen  Expression  yrightparen\n                   |  ynot Factor\n                   |  Setvalue\n                   |  FunctionCall\n                   ;\n/*  Functions with no parameters have no parens, but you don't need         */\n/*  to handle that in FunctionCall because it is handled by Designator.     */\n/*  A FunctionCall has at least one parameter in parens, more are           */\n/*  separated with commas.                                                  */\nFunctionCall       :  yident \n                                {\n                                    printf(\"%s \", $1);\n                                }\n                      ActualParameters\n                   ;\nSetvalue           :  yleftbracket ElementList  yrightbracket\n                   |  yleftbracket yrightbracket\n                   ;\nElementList        :  Element  \n                   |  ElementList  ycomma  Element\n                   ;\nElement            :  ConstExpression  \n                   |  ConstExpression  ydotdot  ConstExpression\n                   ;\n\n/***************************  Subprogram Stuff  ******************************/\n\nSubprogDeclList    :  /*** empty ***/\n                   |  SubprogDeclList ProcedureDecl ysemicolon\n                   |  SubprogDeclList FunctionDecl ysemicolon\n                   ;\nProcedureDecl      :  ProcedureHeading  ysemicolon\n                            {\n                                /* TODO: put in actions.cpp */\n                                /* Put procedure in parent scope */\n                                scopeStack.current->add(&$1);\n                                /* Enter Procedure Scope */\n                                scopeStack.createScope($1.name);\n                                /* Put procedure params on symbol stack. */\n                                std::vector<Procedure> toPutOnStack = $1.getParameters();\n                                for (int i = 0; i < toPutOnStack.size(); i++) {\n                                    current->add(toPutOnStack[i]);\n                                }\n                            }\n                      Block\n                            {\n                                /* TODO: put in actions.cpp */\n                                /* Exit Procedure scope */\n                                StackFrame *scope = stackScope.leaveScope();\n                                /* Print exited scope. */\n                                cout << scope;\n                                /* Mem management */\n                                delete scope;\n                                scope = NULL;\n                            }\n                   ;\nFunctionDecl       :  FunctionHeading  ycolon  yident\n                                {\n                                    printf(\"%s \", $3);\n                                }\n                      ysemicolon  Block\n                   ;\nProcedureHeading   :  yprocedure yident {\n                                {\n                                    printf(\"%s \", $2);\n                                    /* create procedure */\n                                    Procedure procedure(string($2));\n                                    /* Pass procedure back */\n                                    $$ = procedure;\n                                }\n                   |  yprocedure yident {\n                                {\n                                    printf(\"%s \", $2);\n                                }\n                      FormalParameters\n                                {\n                                    /* Create procedure */\n                                    Procedure procedure(string($2)); // NOTE May need to dynamically create?\n                                    /* Add parameters */\n                                    while (!$4.empty()) {\n                                        procedure.addParameter($4.front());\n                                        $4.pop_front();\n                                    }\n                                    /* Pass procedure back */\n                                    $$ = procedure;\n                                }\n                      \n                   ;\nFunctionHeading    :  yfunction  yident\n                                {\n                                    printf(\"%s \", $2);\n                                }\n                   |  yfunction  yident\n                                {\n                                    printf(\"%s \", $2);\n                                }\n                      FormalParameters\n                   ;\nFormalParameters   :  yleftparen FormalParamList yrightparen\n                                {\n                                    $$ = $2; /* TODO Play with removing */\n                                }\n                   ;\nFormalParamList    :  OneFormalParam \n                                {\n                                    //$$.push_back($1);\n                                }\n                   |  FormalParamList ysemicolon OneFormalParam\n                                {\n                                    //$$.push_back($3);\n                                }\n                   ;\nOneFormalParam     :  yvar  IdentList  ycolon  yident\n                                {\n                                    printf(\"%s \", $4);\n                                    /* Search Symbol Table for Type corresponding to yident. */\n                                    Type *type = NULL; // = foundType;\n                                    /* Create parameters and add to parameter queue */\n                                    while (!$2.empty()) {\n                                        Parameter param($2.front(), type, true);\n                                        $$.push_back(param);\n                                        $2.pop_front();\n                                    }\n                                    \n                                }\n                   |  IdentList  ycolon  yident\n                                {\n                                    printf(\"%s \", $3);\n                                    /* TODOSearch Symbol Table for Type corresponding to yident. */\n                                    Type *type = NULL; // = foundType;\n                                    /* Create parameters and add to parameter queue */\n                                    while (!$2.empty()) {\n                                        Parameter param($2.front(), type, false);\n                                        $$.push_back(param);\n                                        $2.pop_front();\n                                    }\n                                }\n                   ;\n\n/***************************  More Operators  ********************************/\n\nUnaryOperator      :  yplus | yminus\n                   ;\nMultOperator       :  ymultiply | ydivide | ydiv | ymod | yand\n                   ;\nAddOperator        :  yplus | yminus | yor\n                   ;\nRelation           :  yequal  | ynotequal | yless | ygreater\n                   |  ylessequal | ygreaterequal | yin\n                   ;\n\n%%\n\n/* program section */\n\nvoid yyerror(const char *s) {\n   cout << s << endl;\n}\n\nextern int yylex();\n\n"]],"start1":0,"start2":0,"length1":0,"length2":17720}]],"length":17720}
{"contributors":["derek.l.mclean@gmail.com"],"silentsave":false,"ts":1352695949809,"patch":[[{"diffs":[[0,"e std;\n\n"],[1,"deque<Parameter> parameterQueue;\ndeque<string> identQueue;\n\n"],[0,"%}\n\n%uni"]],"start1":585,"start2":585,"length1":16,"length2":76},{"diffs":[[0,"re;\n"],[-1,"    deque<Parameter> parameterQueue;\n    deque<string> identQueue;\n}\n\n/* definition section */\n\n%start  CompilationUnit\n%type   <procedure> ProcedureHeading\n%type   <parameterQueue> FormalParameters FormalParamList OneFormalParam\n%type   <identQueue> IdentLis"],[1,"}\n\n/* definition section */\n\n%start  CompilationUni"],[0,"t\n%t"]],"start1":710,"start2":710,"length1":267,"length2":59},{"diffs":[[0," (!$4.empty()) {"],[1," // yacc error ::  yacc: e - line 374 of \"grammar.y\", $4 is untyped"],[0,"\n               "]],"start1":14175,"start2":14175,"length1":32,"length2":99},{"diffs":[[0,"                "],[-1,"$$"],[1,"parameterQueue"],[0,".push_back(param"]],"start1":16163,"start2":16163,"length1":34,"length2":46}]],"length":17651,"saved":false}
{"contributors":[],"silentsave":false,"ts":1352696258828,"patch":[[{"diffs":[[0,"re;\n"],[-1,"}\n\n/* definition section */\n\n%start  CompilationUni"],[1,"    deque<Parameter> parameterQueue;\n    deque<string> identQueue;\n}\n\n/* definition section */\n\n%start  CompilationUnit\n%type   <procedure> ProcedureHeading\n%type   <parameterQueue> FormalParameters FormalParamList OneFormalParam\n%type   <identQueue> IdentLis"],[0,"t\n%t"]],"start1":710,"start2":710,"length1":59,"length2":267},{"diffs":[[0,"hile (!$"],[-1,"4"],[1,"procedureQueue"],[0,".empty()"]],"start1":14379,"start2":14379,"length1":17,"length2":30},{"diffs":[[0,"rameter("],[-1,"$4"],[1,"procedureQueue"],[0,".front()"]],"start1":14535,"start2":14535,"length1":18,"length2":30},{"diffs":[[0,"        "],[-1,"$4"],[1,"procedureQueue"],[0,".pop_fro"]],"start1":14600,"start2":14600,"length1":18,"length2":30},{"diffs":[[0,"// = foundType;\n"],[1,"                                    bool isFound = searchStack(yident, type);\n                                    if (isFound)\n                                    {\n    "],[0,"                "]],"start1":16142,"start2":16142,"length1":32,"length2":201},{"diffs":[[0,"ameter queue */\n"],[1,"    "],[0,"                "]],"start1":16398,"start2":16398,"length1":32,"length2":36},{"diffs":[[0,"                "],[1,"    "],[0,"Parameter param("]],"start1":16500,"start2":16500,"length1":32,"length2":36},{"diffs":[[0,"ype, true);\n"],[1,"    "],[0,"            "]],"start1":16549,"start2":16549,"length1":24,"length2":28},{"diffs":[[0,"                "],[1,"    "],[0,"$2.pop_front();\n"]],"start1":16662,"start2":16662,"length1":32,"length2":36},{"diffs":[[0,"$2.pop_front();\n"],[1,"                                        }\n"],[0,"                "]],"start1":16682,"start2":16682,"length1":32,"length2":74},{"diffs":[[0,"// = foundType;\n"],[1,"                                    bool isFound = searchStack(yident, type);\n                                    if (isFound)\n                                    {\n    "],[0,"                "]],"start1":17141,"start2":17141,"length1":32,"length2":201},{"diffs":[[0,"                "],[1,"  "],[1,"  "],[0,"while (!$2.empty"]],"start1":17433,"start2":17433,"length1":32,"length2":36},{"diffs":[[0,"(!$2.empty()) {\n"],[1,"    "],[0,"                "]],"start1":17459,"start2":17459,"length1":32,"length2":36},{"diffs":[[0,"                "],[-1,"$$"],[1,"    parameterQueue"],[0,".push_back(param"]],"start1":17585,"start2":17585,"length1":34,"length2":50},{"diffs":[[0,"                "],[1,"    "],[0,"$2.pop_front();\n"]],"start1":17662,"start2":17662,"length1":32,"length2":36},{"diffs":[[0,"$2.pop_front();\n"],[1,"                                        }\n"],[0,"                "]],"start1":17682,"start2":17682,"length1":32,"length2":74}]],"length":18362,"saved":false}
{"contributors":["derek.l.mclean@gmail.com"],"silentsave":false,"ts":1352696837062,"patch":[[{"diffs":[[0,"ing\n"],[-1,"%type   <parameterQueue> FormalParameters FormalParamList OneFormalParam\n%type   <identQueue> IdentList\n"],[0,"%tok"]],"start1":867,"start2":867,"length1":112,"length2":8},{"diffs":[[0,"ren  ysemico"],[1,"a"],[0,"lon yset \n  "]],"start1":1294,"start2":1294,"length1":24,"length2":25},{"diffs":[[0,"                "],[-1,"$$"],[1,"identQueue"],[0,".push_back($1);\n"]],"start1":2355,"start2":2355,"length1":34,"length2":42},{"diffs":[[0,"        "],[-1,"$$"],[1,"identQueue"],[0,".push_ba"]],"start1":2594,"start2":2594,"length1":18,"length2":26},{"diffs":[[0,"while (!"],[-1,"$"],[0,""],[1,""],[0,"procedur"]],"start1":14291,"start2":14291,"length1":17,"length2":16},{"diffs":[[0,"  }\n"],[-1,"                                    /* Pass procedure back */\n                                    $$ = procedure;\n"],[0,"    "]],"start1":14582,"start2":14582,"length1":122,"length2":8},{"diffs":[[0,"      }\n"],[-1,"                      \n"],[0,"        "]],"start1":14612,"start2":14612,"length1":39,"length2":16},{"diffs":[[0," bool isFound = "],[1,"scopeStack."],[0,"searchStack(yide"]],"start1":15968,"start2":15968,"length1":32,"length2":43},{"diffs":[[0,"            "],[-1,"if (isFound)"],[1,"/* Create parameters and add to parameter queue */"],[0,"\n           "]],"start1":16046,"start2":16046,"length1":36,"length2":74},{"diffs":[[0,"            "],[-1,"{\n      "],[1,"if (isFound)\n"],[0,"            "]],"start1":16133,"start2":16133,"length1":32,"length2":37},{"diffs":[[0,"    "],[-1,"/* Create parameters and add to parameter queue */"],[1,"  {"],[0,"\n   "]],"start1":16188,"start2":16188,"length1":58,"length2":11},{"diffs":[[0,"        while (!"],[-1,"$2"],[1,"identQueue"],[0,".empty()) {\n    "]],"start1":16228,"start2":16228,"length1":34,"length2":42},{"diffs":[[0,"Parameter param("],[-1,"$2"],[1,"identQueue"],[0,".front(), type, "]],"start1":16310,"start2":16310,"length1":34,"length2":42},{"diffs":[[0,"                "],[-1,"$2"],[1,"identQueue"],[0,".pop_front();\n  "]],"start1":16464,"start2":16464,"length1":34,"length2":42},{"diffs":[[0,"  }\n"],[-1,"                                    \n"],[0,"    "]],"start1":16580,"start2":16580,"length1":45,"length2":8},{"diffs":[[0," /* TODO"],[1," "],[0,"Search S"]],"start1":16790,"start2":16790,"length1":16,"length2":17},{"diffs":[[0,"    "],[-1,"bool isFound = searchStack(yident, type);\n                                    if (isFound)\n                                    {\n    "],[1,"\n"],[0,"    "]],"start1":16959,"start2":16959,"length1":141,"length2":9},{"diffs":[[0,"    "],[-1,"    "],[0,"while (!"],[-1,"$2"],[1,"identQueue"],[0,".emp"]],"start1":17083,"start2":17083,"length1":22,"length2":26},{"diffs":[[0,"ueue.empty()) {\n"],[-1,"    "],[0,"                "]],"start1":17101,"start2":17101,"length1":36,"length2":32},{"diffs":[[0,"r param("],[-1,"$2"],[1,"identQueue"],[0,".front()"]],"start1":17165,"start2":17165,"length1":18,"length2":26},{"diffs":[[0,"pe, false);\n"],[-1,"    "],[0,"            "]],"start1":17195,"start2":17195,"length1":28,"length2":24},{"diffs":[[0,"    "],[-1,"    $2"],[1,"identQueue"],[0,".pop"]],"start1":17316,"start2":17316,"length1":14,"length2":18},{"diffs":[[0,"();\n"],[-1,"                                        }\n"],[0,"    "]],"start1":17340,"start2":17340,"length1":50,"length2":8}]],"length":17966,"saved":false}
{"contributors":["carameldropz17@gmail.com","derek.l.mclean@gmail.com"],"silentsave":false,"ts":1352701020211,"patch":[[{"diffs":[[0,"ntQueue;"],[1,"\nbool validBlock;"],[0,"\n\n%}\n\n%u"]],"start1":643,"start2":643,"length1":16,"length2":33},{"diffs":[[0,"    "],[-1,"deque<Parameter> parameterQueue"],[1,"Function *function"],[0,";\n  "]],"start1":731,"start2":731,"length1":39,"length2":26},{"diffs":[[0,"ionUnit\n"],[-1,""],[0,"%type   "]],"start1":830,"start2":830,"length1":16,"length2":16},{"diffs":[[0,"Heading\n"],[1,"%type   <function>  FunctionHeading\n"],[0,"%token  "]],"start1":867,"start2":867,"length1":16,"length2":52},{"diffs":[[0,"pe(string($2));\n"],[1,"                                    validBlock = true;\n"],[0,"                "]],"start1":1991,"start2":1991,"length1":32,"length2":87},{"diffs":[[0,"Scope($1"],[-1,"."],[1,"->"],[0,"name);\n "]],"start1":12291,"start2":12291,"length1":17,"length2":18},{"diffs":[[0,"vector<P"],[-1,"rocedure"],[1,"arameter"],[0,"> toPutO"]],"start1":12421,"start2":12421,"length1":24,"length2":24},{"diffs":[[0,"ack = $1"],[-1,"."],[1,"->"],[0,"getParam"]],"start1":12448,"start2":12448,"length1":17,"length2":18},{"diffs":[[0,"    "],[-1,"    {\n                                    printf(\"%s \", $3);"],[1,"{\n                                /* TODO: put in actions.cpp */\n                                /* Check if return type is valid */\n                                Type *type = NULL;\n                                validBlock = scopeStack.searchStack(yident, type);\n                                /* Put function in parent scope */\n                                if (validBlock)\n                                {\n                                    scopeStack.current->add(&$1);\n                                    /* Enter Function Scope */\n                                    scopeStack.createScope($1->name);\n                                    /* Put procedure params on symbol stack. */\n                                    std::vector<Parameter> toPutOnStack = $1->getParameters();\n                                    for (int i = 0; i < toPutOnStack.size(); i++) {\n                                        current->add(toPutOnStack[i]);\n                                    }\n                                }\n                                else    //New scope not created, new parameters not added\n                                {\n                                    //Do Mem management "],[0,"\n   "]],"start1":13322,"start2":13322,"length1":68,"length2":1205},{"diffs":[[0,"              }\n"],[1,"                            }\n"],[0,"                "]],"start1":14542,"start2":14542,"length1":32,"length2":62},{"diffs":[[0,"    "],[-1,";\nProcedureHeading   :  yprocedure yident {"],[1,"         {\n                                /* TODO: put in actions.cpp */\n                                /* Exit Function scope */\n                                if (validBlock)\n                                {\n                                    StackFrame *scope = stackScope.leaveScope();\n                                    /* Print exited scope. */\n                                    cout << scope;\n                                    /* Mem management */\n                                    delete scope;\n                                    scope = NULL;\n                                }"],[0,"\n   "]],"start1":14643,"start2":14643,"length1":51,"length2":606},{"diffs":[[0,"                "],[-1,"{"],[1,"validBlock = true;"],[0,"\n               "]],"start1":15262,"start2":15262,"length1":33,"length2":50},{"diffs":[[0,"    "],[1,"}\n"],[0,"        "],[-1,"printf(\"%s \", $2);"],[1,"           ;\nProcedureHeading   :  yprocedure yident {\n                                {"],[0,"\n   "]],"start1":15321,"start2":15321,"length1":34,"length2":106},{"diffs":[[0,"create procedure"],[1," Check if name already taken?"],[0," */\n            "]],"start1":15463,"start2":15463,"length1":32,"length2":61},{"diffs":[[0,"      Procedure "],[-1,"p"],[1,"*procedure = new P"],[0,"rocedure(string("]],"start1":15542,"start2":15542,"length1":33,"length2":50},{"diffs":[[0,"ocedure "],[-1,"p"],[1,"*procedure = new P"],[0,"rocedure"]],"start1":16081,"start2":16081,"length1":17,"length2":34},{"diffs":[[0,"              }\n"],[1,"                                    $$ = procedure;\n"],[0,"                "]],"start1":16541,"start2":16541,"length1":32,"length2":84},{"diffs":[[0,"    "],[-1,"}\n                   |  yfunction  yident\n                                {\n                                    printf(\"%s \", $2);\n                                }\n                      FormalParameters"],[1,"    /* create function  Check if name already taken? */\n                                    Function *function = new Function(string($2));\n                                    /* Pass function back */\n                                    $$ = function;\n                                }\n                   |  yfunction  yident\n                                {\n                                    printf(\"%s \", $2);\n                                }\n                      FormalParameters\n                                {\n                                    /* Create function */\n                                    Function *function = new Function(string($2)); // NOTE May need to dynamically create?\n                                    /* Add parameters */\n                                    while (!procedureQueue.empty()) { // yacc error ::  yacc: e - line 374 of \"grammar.y\", $4 is untyped\n                                        function.addParameter(functionQueue.front());\n                                        functionQueue.pop_front();\n                                    }\n                                    $$ = function;\n                                }"],[0,"\n   "]],"start1":16821,"start2":16821,"length1":211,"length2":1179},{"diffs":[[0,"tQueue.empty()) "],[-1,""],[0,""],[1,"\n                                        "],[0,"{\n              "]],"start1":19239,"start2":19239,"length1":32,"length2":73},{"diffs":[[0,"        "],[1,"bool isFound = scopeStack.searchStack(yident, type);"],[0,"\n       "]],"start1":19987,"start2":19987,"length1":16,"length2":68},{"diffs":[[0,"ameter queue */\n"],[1,"                                    if (isFound)\n                                    {\n    "],[0,"                "]],"start1":20119,"start2":20119,"length1":32,"length2":123},{"diffs":[[0,".empty()) {\n"],[1,"    "],[0,"            "]],"start1":20280,"start2":20280,"length1":24,"length2":28},{"diffs":[[0,"                "],[1," "],[1,"   "],[0,"parameterQueue.p"]],"start1":20410,"start2":20410,"length1":32,"length2":36},{"diffs":[[0,"                "],[1,"    "],[0,"identQueue.pop_f"]],"start1":20487,"start2":20487,"length1":32,"length2":36},{"diffs":[[0,"ue.pop_front();\n"],[1,"                                        }\n"],[0,"                "]],"start1":20515,"start2":20515,"length1":32,"length2":74}]],"length":21195,"saved":false}
{"contributors":["derek.l.mclean@gmail.com","carameldropz17@gmail.com"],"silentsave":false,"ts":1352704894186,"patch":[[{"diffs":[[0," *function;\n"],[1,"    Type *type;\n"],[0,"    deque<st"]],"start1":743,"start2":743,"length1":24,"length2":40},{"diffs":[[0,"Heading\n"],[1,"%type   <type> Type\n"],[0,"%token  "]],"start1":919,"start2":919,"length1":16,"length2":36},{"diffs":[[0,"t  ycolon  Type\n"],[1,"                                {\n                                    /* TODO Search Symbol Table for Type corresponding to yident. */\n                                    /* If Type was  */\n                                    Type *type = NULL; // = foundType;\n                                    bool isFound = scopeStack.searchStack(yident, type);\n                                    /* Create parameters and add to parameter queue */\n                                    if (isFound)\n                                    {\n                                        while (!identQueue.empty()) {\n                                            Variable var(identQueue.front(), type);\n                                            // TODO Add symbol\n                                            identQueue.pop_front();\n                                        }\n                                    }\n                                }\n"],[0,"                "]],"start1":4266,"start2":4266,"length1":32,"length2":955},{"diffs":[[0,"ntf(\"%s \", $1);\n"],[1,"                                    Type *type = NULL;\n                                    bool isFound = scopeStack.searchStack(yident, type);\n                                    if (isFound) {\n                                        $$ = type;\n                                    }\n"],[0,"                "]],"start1":5756,"start2":5756,"length1":32,"length2":316}]],"length":22438,"saved":false}
